
"""
Задание 3.

Для этой задачи:
1) придумайте 1-3 решения (желательно хотя бы два)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.


Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
"""
##################################################################################################

# O(n)
from collections import Counter

company_dict = {'company_1': 589632147,           # O(1)
                'company_2': 654789,
                'company_3': 789654123698,
                'company_4': 741258,
                'company_5': 32145696587412,
                'company_6': 963258741123}



k = Counter(company_dict)                       # O(1)

# Нахождение 3 самых высоких значений

high = k.most_common(3)                         # O(n)

print('Список компаний, Компания:  Прибыль ')

print(company_dict)

print("Список 3-х самых прибыльных компаний")

print("Компания   :  Прибыль")

for i in high:                                 # O(n)
    print(i[0], " :", i[1], " ")

# Оптимальный, средний по сложности алгоритм, линейный.
#############################################################################################################

from collections import Counter

company_dict = {'company_1': 589632147,           # O(1)
                'company_2': 654789,
                'company_3': 789654123698,
                'company_4': 741258,
                'company_5': 32145696587412,
                'company_6': 963258741123}

count = Counter(company_dict)                    # O(1)
print(count.most_common(3))

# На мой взгляд, самый простой по сложности алгоритм, поскольку данные в словаре постоянны т.е. константы,
# следовательно затраченное время для простого вывода ключ:значение постоянно.
#############################################################################################################
# O(n^2)
company_dict = {'':0,
                'company_1': 589632147,           # O(1)
                'company_2': 654789,
                'company_3': 789654123698,
                'company_4': 741258,
                'company_5': 32145696587412,
                'company_6': 963258741123}

aux = sorted([(value,key) for (key,value) in company_dict.items()])   # O(n^2)
res = [(value,key) for (key,value) in aux[-3:]]
print(res)

# Использование цикла неизбежно увеличивает сложность алгоритма, приводя к квадротичной сложности
#################################################################################################################
